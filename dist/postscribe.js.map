{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 51ed5a4dd91c0b7ca755","webpack:///./src/main.js","webpack:///./src/postscribe.js","webpack:///./src/write-stream.js","webpack:///./~/prescribe/dist/prescribe.js","webpack:///./src/utils.js"],"names":["module","exports","postscribe","utils","doNothing","OPTIONS","afterAsync","afterDequeue","afterStreamStart","afterWrite","autoFix","beforeEnqueue","beforeWriteToken","tok","beforeWrite","str","done","error","e","Error","msg","releaseAsync","nextId","queue","active","nextStream","args","shift","options","last","stream","runStream","el","html","WriteStream","id","name","streams","doc","ownerDocument","stash","close","open","write","writeln","join","win","console","debug","oldOnError","onerror","url","line","apply","isFunction","defaults","test","window","document","getElementById","substr","jquery","cancel","abort","push","DEBUG_CHUNK","BASEATTR","PROXY_STYLE","PROXY_SCRIPT","getData","attr","val","getAttribute","existy","String","setData","value","setAttribute","removeAttribute","root","defaultView","parentWindow","parser","HtmlParser","actuals","proxyHistory","proxyRoot","createElement","nodeName","scriptStack","writeQueue","deferredRemote","length","arg","_callFunction","_writeImpl","fn","type","toString","_onScriptStart","call","_onScriptDone","append","script","style","tokens","readToken","isScript","isStyle","_writeStaticTokens","_handleScriptToken","_handleStyleToken","chunk","_buildChunk","actual","proxy","innerHTML","proxyInnerHTML","_walkChunk","actualInnerHTML","raw","len","i","tokenRaw","attrs","tagName","replace","unary","node","stack","isElement","nodeType","isProxy","parentIsProxyOf","parentNode","appendChild","unshift","toArray","childNodes","remainder","clear","src","SRC","_writeScriptToken","TYPE","_writeStyleToken","_buildStyle","_insertCursor","content","styleSheet","sheet","cssText","createTextNode","eachKey","which","cursor","replaceChild","outerWrites","_buildScript","asyncRelease","_shouldRelease","_scriptLoadHandler","text","cleanup","onload","onreadystatechange","success","failure","err","reattachEventListener","evt","handler","_onload","Array","prototype","slice","arguments","_onerror","readyState","hasAttribute","each","isTag","thing","x","arr","target","obj","key","hasOwnProperty","_defaults","ret","array","tag","toLowerCase","indexOf"],"mappings":"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;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA,SAAQ;AACR,OAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,OAAO;AACvB;;;AAGA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,GAAE;AACF;AACA;;AAEA;;AAEA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA,SAAQ;;AAER;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,mDAAkD,0CAA0C,0DAA0D,EAAE;;AAExJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,SAAS;AACvB,eAAc,QAAQ;AACtB,iBAAgB,OAAO;AACvB;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA,eAAc,QAAQ;AACtB,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB,eAAc,OAAO;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAE;;AAEF,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,OAAO;AACnB,aAAY,OAAO;AACnB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;;AAEA,QAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,WAAW;AACvB,aAAY,SAAS;AACrB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,WAAW;AACvB,aAAY,aAAa;AACzB;AACA;AACA;;AAEA;AACA;AA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","file":"postscribe.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"postscribe\"] = factory();\n\telse\n\t\troot[\"postscribe\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 51ed5a4dd91c0b7ca755","import postscribe from './postscribe';\n\nmodule.exports = postscribe;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","import WriteStream from \"./write-stream\";\nimport * as utils from \"./utils\";\n\n/**\n * A function that intentionally does nothing.\n */\nfunction doNothing() {}\n\n/**\n * Available options and defaults.\n *\n * @type {Object}\n */\nconst OPTIONS = {\n  /**\n   * Called when an async script has loaded.\n   */\n  afterAsync: doNothing,\n\n  /**\n   * Called immediately before removing from the write queue.\n   */\n  afterDequeue: doNothing,\n\n  /**\n   * Called sync after a stream's first thread release.\n   */\n  afterStreamStart: doNothing,\n\n  /**\n   * Called after writing buffered document.write calls.\n   */\n  afterWrite: doNothing,\n\n  /**\n   * Allows disabling the autoFix feature of prescribe\n   */\n  autoFix: true,\n\n  /**\n   * Called immediately before adding to the write queue.\n   */\n  beforeEnqueue: doNothing,\n\n  /**\n   * Called before writing a token.\n   *\n   * @param {Object} tok The token\n   */\n  beforeWriteToken: (tok) => tok,\n\n  /**\n   * Called before writing buffered document.write calls.\n   *\n   * @param {String} str The string\n   */\n  beforeWrite: (str) => str,\n\n  /**\n   * Called when evaluation is finished.\n   */\n  done: doNothing,\n\n  /**\n   * Called when a write results in an error.\n   *\n   * @param {Error} e The error\n   */\n  error(e) {\n    throw new Error(e.msg);\n  },\n\n  /**\n   * Whether to let scripts w/ async attribute set fall out of the queue.\n   */\n  releaseAsync: false,\n};\n\nlet nextId = 0;\nlet queue = [];\nlet active = null;\n\nfunction nextStream() {\n  const args = queue.shift();\n  if (args) {\n    const options = utils.last(args);\n\n    options.afterDequeue();\n    args.stream = runStream(...args);\n    options.afterStreamStart();\n  }\n}\n\nfunction runStream(el, html, options) {\n  active = new WriteStream(el, options);\n\n  // Identify this stream.\n  active.id = nextId++;\n  active.name = options.name || active.id;\n  postscribe.streams[active.name] = active;\n\n  // Override document.write.\n  const doc = el.ownerDocument;\n\n  const stash = {\n    close: doc.close,\n    open: doc.open,\n    write: doc.write,\n    writeln: doc.writeln,\n  };\n\n  function write(str) {\n    str = options.beforeWrite(str);\n    active.write(str);\n    options.afterWrite(str);\n  }\n\n  Object.assign(doc, {\n    close: doNothing,\n    open: doNothing,\n    write: (...str) => write(str.join(\"\")),\n    writeln: (...str) => write(str.join(\"\") + \"\\n\"),\n  });\n\n  if (!active.win) {\n    console.debug(`Active window removed from DOM`, active);\n    return active;\n  }\n\n  // Override window.onerror\n  const oldOnError = active.win.onerror || doNothing;\n\n  // This works together with the try/catch around WriteStream::insertScript\n  // In modern browsers, exceptions in tag scripts go directly to top level\n  active.win.onerror = (msg, url, line) => {\n    options.error({ msg: `${msg} - ${url}: ${line}` });\n    oldOnError.apply(active.win, [msg, url, line]);\n  };\n\n  // Write to the stream\n  active.write(html, () => {\n    // restore document.write\n    Object.assign(doc, stash);\n\n    // restore window.onerror\n    active.win.onerror = oldOnError;\n\n    options.done();\n    active = null;\n    nextStream();\n  });\n\n  return active;\n}\n\nexport default function postscribe(el, html, options) {\n  if (utils.isFunction(options)) {\n    options = { done: options };\n  } else if (options === \"clear\") {\n    queue = [];\n    active = null;\n    nextId = 0;\n    return;\n  }\n\n  options = utils.defaults(options, OPTIONS);\n\n  // id selector\n  if (/^#/.test(el)) {\n    el = window.document.getElementById(el.substr(1));\n  } else {\n    el = el.jquery ? el[0] : el;\n  }\n\n  const args = [el, html, options];\n\n  el.postscribe = {\n    cancel: () => {\n      if (args.stream) {\n        args.stream.abort();\n      } else {\n        args[1] = doNothing;\n      }\n    },\n  };\n\n  options.beforeEnqueue(args);\n  queue.push(args);\n\n  if (!active) {\n    nextStream();\n  }\n\n  return el.postscribe;\n}\n\nObject.assign(postscribe, {\n  // Streams by name.\n  streams: {},\n  // Queue of streams.\n  queue,\n  // Expose internal classes.\n  WriteStream,\n});\n\n\n\n// WEBPACK FOOTER //\n// ./src/postscribe.js","import HtmlParser from 'prescribe';\nimport * as utils from './utils';\n\n/**\n * Turn on to debug how each chunk affected the DOM.\n * @type {boolean}\n */\nconst DEBUG_CHUNK = false;\n\n/**\n * Prefix for data attributes on DOM elements.\n * @type {string}\n */\nconst BASEATTR = 'data-ps-';\n\n/**\n * ID for the style proxy\n * @type {string}\n */\nconst PROXY_STYLE = 'ps-style';\n\n/**\n * ID for the script proxy\n * @type {string}\n */\nconst PROXY_SCRIPT = 'ps-script';\n\n/**\n * Get data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @returns {String}\n */\nfunction getData(el, name) {\n  const attr = BASEATTR + name;\n\n  const val = el.getAttribute(attr);\n\n  // IE 8 returns a number if it's a number\n  return !utils.existy(val) ? val : String(val);\n}\n\n/**\n * Set data attributes\n *\n * @param {Object} el The DOM element.\n * @param {String} name The attribute name.\n * @param {null|*} value The attribute value.\n */\nfunction setData(el, name, value = null) {\n  const attr = BASEATTR + name;\n\n  if (utils.existy(value) && value !== '') {\n    el.setAttribute(attr, value);\n  } else {\n    el.removeAttribute(attr);\n  }\n}\n\n/**\n * Stream static html to an element, where \"static html\" denotes \"html\n * without scripts\".\n *\n * This class maintains a *history of writes devoid of any attributes* or\n * \"proxy history\".\n *\n * Injecting the proxy history into a temporary div has no side-effects,\n * other than to create proxy elements for previously written elements.\n *\n * Given the `staticHtml` of a new write, a `tempDiv`'s innerHTML is set to\n * `proxy_history + staticHtml`.\n * The *structure* of `tempDiv`'s contents, (i.e., the placement of new nodes\n * beside or inside of proxy elements), reflects the DOM structure that would\n * have resulted if all writes had been squashed into a single write.\n *\n * For each descendent `node` of `tempDiv` whose parentNode is a *proxy*,\n * `node` is appended to the corresponding *real* element within the DOM.\n *\n * Proxy elements are mapped to *actual* elements in the DOM by injecting a\n * `data-id` attribute into each start tag in `staticHtml`.\n *\n */\nexport default class WriteStream {\n  /**\n   * Constructor.\n   *\n   * @param {Object} root The root element\n   * @param {?Object} options The options\n   */\n  constructor(root, options = {}) {\n    this.root = root;\n    this.options = options;\n    this.doc = root.ownerDocument;\n    this.win = this.doc.defaultView || this.doc.parentWindow;\n    this.parser = new HtmlParser('', {autoFix: options.autoFix});\n\n    // Actual elements by id.\n    this.actuals = [root];\n\n    // Embodies the \"structure\" of what's been written so far,\n    // devoid of attributes.\n    this.proxyHistory = '';\n\n    // Create a proxy of the root element.\n    this.proxyRoot = this.doc.createElement(root.nodeName);\n\n    this.scriptStack = [];\n    this.writeQueue = [];\n\n    setData(this.proxyRoot, 'proxyof', 0);\n  }\n\n  /**\n   * Writes the given strings.\n   *\n   * @param {...String} str The strings to write\n   */\n  write(...str) {\n    this.writeQueue.push(...str);\n\n    // Process writes\n    // When new script gets pushed or pending this will stop\n    // because new writeQueue gets pushed\n    while (!this.deferredRemote && this.writeQueue.length) {\n      const arg = this.writeQueue.shift();\n\n      if (utils.isFunction(arg)) {\n        this._callFunction(arg);\n      } else {\n        this._writeImpl(arg);\n      }\n    }\n  }\n\n  /**\n   * Calls the given function.\n   *\n   * @param {Function} fn The function to call\n   * @private\n   */\n  _callFunction(fn) {\n    const tok = {type: 'function', value: fn.name || fn.toString()};\n    this._onScriptStart(tok);\n    fn.call(this.win, this.doc);\n    this._onScriptDone(tok);\n  }\n\n  /**\n   * The write implementation\n   *\n   * @param {String} html The HTML to write.\n   * @private\n   */\n  _writeImpl(html) {\n    this.parser.append(html);\n\n    let tok;\n    let script;\n    let style;\n    const tokens = [];\n\n    // stop if we see a script token\n    while ((tok = this.parser.readToken()) &&\n      !(script = utils.isScript(tok)) &&\n      !(style = utils.isStyle(tok))) {\n      tok = this.options.beforeWriteToken(tok);\n\n      if (tok) {\n        tokens.push(tok);\n      }\n    }\n\n    if (tokens.length > 0) {\n      this._writeStaticTokens(tokens);\n    }\n\n    if (script) {\n      this._handleScriptToken(tok);\n    }\n\n    if (style) {\n      this._handleStyleToken(tok);\n    }\n  }\n\n  /**\n   * Write contiguous non-script tokens (a chunk)\n   *\n   * @param {Array<Object>} tokens The tokens\n   * @returns {{tokens, raw, actual, proxy}|null}\n   * @private\n   */\n  _writeStaticTokens(tokens) {\n    const chunk = this._buildChunk(tokens);\n\n    if (!chunk.actual) {\n      // e.g., no tokens, or a noscript that got ignored\n      return null;\n    }\n\n    chunk.html = this.proxyHistory + chunk.actual;\n    this.proxyHistory += chunk.proxy;\n    this.proxyRoot.innerHTML = chunk.html;\n\n    if (DEBUG_CHUNK) {\n      chunk.proxyInnerHTML = this.proxyRoot.innerHTML;\n    }\n\n    this._walkChunk();\n\n    if (DEBUG_CHUNK) {\n      chunk.actualInnerHTML = this.root.innerHTML;\n    }\n\n    return chunk;\n  }\n\n  /**\n   * Build a chunk.\n   *\n   * @param {Array<Object>} tokens The tokens to use.\n   * @returns {{tokens: *, raw: string, actual: string, proxy: string}}\n   * @private\n   */\n  _buildChunk(tokens) {\n    let nextId = this.actuals.length;\n\n    // The raw html of this chunk.\n    const raw = [];\n\n    // The html to create the nodes in the tokens (with id's injected).\n    const actual = [];\n\n    // Html that can later be used to proxy the nodes in the tokens.\n    const proxy = [];\n\n    const len = tokens.length;\n    for (let i = 0; i < len; i++) {\n      const tok = tokens[i];\n      const tokenRaw = tok.toString();\n\n      raw.push(tokenRaw);\n\n      if (tok.attrs) { // tok.attrs <==> startTag or atomicTag or cursor\n        // Ignore noscript tags. They are atomic, so we don't have to worry about children.\n        if (!(/^noscript$/i).test(tok.tagName)) {\n          const id = nextId++;\n\n          // Actual: inject id attribute: replace '>' at end of start tag with id attribute + '>'\n          actual.push(tokenRaw.replace(/(\\/?>)/, ` ${BASEATTR}id=${id} $1`));\n\n          // Don't proxy scripts: they have no bearing on DOM structure.\n          if (tok.attrs.id !== PROXY_SCRIPT && tok.attrs.id !== PROXY_STYLE) {\n            // Proxy: strip all attributes and inject proxyof attribute\n            proxy.push(\n              // ignore atomic tags (e.g., style): they have no \"structural\" effect\n              tok.type === 'atomicTag' ? '' :\n              `<${tok.tagName} ${BASEATTR}proxyof=${id}` + (tok.unary ? ' />' : '>')\n            );\n          }\n        }\n      } else {\n        // Visit any other type of token\n        // Actual: append.\n        actual.push(tokenRaw);\n\n        // Proxy: append endTags. Ignore everything else.\n        proxy.push(tok.type === 'endTag' ? tokenRaw : '');\n      }\n    }\n\n    return {\n      tokens,\n      raw: raw.join(''),\n      actual: actual.join(''),\n      proxy: proxy.join('')\n    };\n  }\n\n  /**\n   * Walk the chunks.\n   *\n   * @private\n   */\n  _walkChunk() {\n    let node;\n    const stack = [this.proxyRoot];\n\n    // use shift/unshift so that children are walked in document order\n    while (utils.existy(node = stack.shift())) {\n      const isElement = node.nodeType === 1;\n      const isProxy = isElement && getData(node, 'proxyof');\n\n      // Ignore proxies\n      if (!isProxy) {\n        if (isElement) {\n          // New actual element: register it and remove the the id attr.\n          this.actuals[getData(node, 'id')] = node;\n          setData(node, 'id');\n        }\n\n        // Is node's parent a proxy?\n        const parentIsProxyOf = node.parentNode &&\n          getData(node.parentNode, 'proxyof');\n        if (parentIsProxyOf) {\n          // Move node under actual parent.\n          this.actuals[parentIsProxyOf].appendChild(node);\n        }\n      }\n\n      // prepend childNodes to stack\n      stack.unshift.apply(stack, utils.toArray(node.childNodes));\n    }\n  }\n\n  /**\n   * Handles Script tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleScriptToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this script.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.src = tok.attrs.src || tok.attrs.SRC;\n\n    tok = this.options.beforeWriteToken(tok);\n    if (!tok) {\n      // User has removed this token\n      return;\n    }\n\n    if (tok.src && this.scriptStack.length) {\n      // Defer this script until scriptStack is empty.\n      // Assumption 1: This script will not start executing until\n      // scriptStack is empty.\n      this.deferredRemote = tok;\n    } else {\n      this._onScriptStart(tok);\n    }\n\n    // Put the script node in the DOM.\n    this._writeScriptToken(tok, () => {\n      this._onScriptDone(tok);\n    });\n  }\n\n  /**\n   * Handles style tokens\n   *\n   * @param {Object} tok The token\n   */\n  _handleStyleToken(tok) {\n    const remainder = this.parser.clear();\n\n    if (remainder) {\n      // Write remainder immediately behind this style.\n      this.writeQueue.unshift(remainder);\n    }\n\n    tok.type = tok.attrs.type || tok.attrs.TYPE || 'text/css';\n\n    tok = this.options.beforeWriteToken(tok);\n\n    if (tok) {\n      // Put the style node in the DOM.\n      this._writeStyleToken(tok);\n    }\n\n    if (remainder) {\n      this.write();\n    }\n  }\n\n  /**\n   * Build a style and insert it into the DOM.\n   *\n   * @param {Object} tok The token\n   */\n  _writeStyleToken(tok) {\n    const el = this._buildStyle(tok);\n\n    this._insertCursor(el, PROXY_STYLE);\n\n    // Set content\n    if (tok.content) {\n      if (el.styleSheet && !el.sheet) {\n        el.styleSheet.cssText = tok.content;\n      } else {\n        el.appendChild(this.doc.createTextNode(tok.content));\n      }\n    }\n  }\n\n  /**\n   * Build a style element from an atomic style token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildStyle(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    el.setAttribute('type', tok.type);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    return el;\n  }\n\n  /**\n   * Append a span to the stream. That span will act as a cursor\n   * (i.e. insertion point) for the element.\n   *\n   * @param {Object} el The element\n   * @param {string} which The type of proxy element\n   */\n  _insertCursor(el, which) {\n    this._writeImpl(`<span id=\"${which}\"/>`);\n\n    const cursor = this.doc.getElementById(which);\n\n    if (cursor) {\n      cursor.parentNode.replaceChild(el, cursor);\n    }\n  }\n\n  /**\n   * Called when a script is started.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptStart(tok) {\n    tok.outerWrites = this.writeQueue;\n    this.writeQueue = [];\n    this.scriptStack.unshift(tok);\n  }\n\n  /**\n   * Called when a script is done.\n   *\n   * @param {Object} tok The token\n   * @private\n   */\n  _onScriptDone(tok) {\n    // Pop script and check nesting.\n    if (tok !== this.scriptStack[0]) {\n      this.options.error({msg: 'Bad script nesting or script finished twice'});\n      return;\n    }\n\n    this.scriptStack.shift();\n\n    // Append outer writes to queue and process them.\n    this.write.apply(this, tok.outerWrites);\n\n    // Check for pending remote\n\n    // Assumption 2: if remote_script1 writes remote_script2 then\n    // the we notice remote_script1 finishes before remote_script2 starts.\n    // I think this is equivalent to assumption 1\n    if (!this.scriptStack.length && this.deferredRemote) {\n      this._onScriptStart(this.deferredRemote);\n      this.deferredRemote = null;\n    }\n  }\n\n  /**\n   * Build a script and insert it into the DOM.\n   * Done is called once script has executed.\n   *\n   * @param {Object} tok The token\n   * @param {Function} done The callback when complete\n   */\n  _writeScriptToken(tok, done) {\n    const el = this._buildScript(tok);\n    const asyncRelease = this._shouldRelease(el);\n    const afterAsync = this.options.afterAsync;\n\n    if (tok.src) {\n      // Fix for attribute \"SRC\" (capitalized). IE does not recognize it.\n      el.src = tok.src;\n      this._scriptLoadHandler(el, !asyncRelease ? () => {\n        done();\n        afterAsync();\n      } : afterAsync);\n    }\n\n    try {\n      this._insertCursor(el, PROXY_SCRIPT);\n      if (!el.src || asyncRelease) {\n        done();\n      }\n    } catch (e) {\n      this.options.error(e);\n      done();\n    }\n  }\n\n  /**\n   * Build a script element from an atomic script token.\n   *\n   * @param {Object} tok The token\n   * @returns {Element}\n   */\n  _buildScript(tok) {\n    const el = this.doc.createElement(tok.tagName);\n\n    // Set attributes\n    utils.eachKey(tok.attrs, (name, value) => {\n      el.setAttribute(name, value);\n    });\n\n    // Set content\n    if (tok.content) {\n      el.text = tok.content;\n    }\n\n    return el;\n  }\n\n  /**\n   * Setup the script load handler on an element.\n   *\n   * @param {Object} el The element\n   * @param {Function} done The callback\n   * @private\n   */\n  _scriptLoadHandler(el, done) {\n    function cleanup() {\n      el = el.onload = el.onreadystatechange = el.onerror = null;\n    }\n\n    const error = this.options.error;\n\n    function success() {\n      cleanup();\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function failure(err) {\n      cleanup();\n      error(err);\n      if (done != null) {\n        done();\n      }\n      done = null;\n    }\n\n    function reattachEventListener(el, evt) {\n      const handler = el[`on${evt}`];\n      if (handler != null) {\n        el[`_on${evt}`] = handler;\n      }\n    }\n\n    reattachEventListener(el, 'load');\n    reattachEventListener(el, 'error');\n\n    Object.assign(el, {\n      onload() {\n        if (el._onload) {\n          try {\n            el._onload.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onload handler failed ${err} @ ${el.src}`});\n          }\n        }\n        success();\n      },\n\n      onerror() {\n        if (el._onerror) {\n          try {\n            el._onerror.apply(this, Array.prototype.slice.call(arguments, 0));\n          } catch (err) {\n            failure({msg: `onerror handler failed ${err} @ ${el.src}`});\n            return;\n          }\n        }\n        failure({msg: `remote script failed ${el.src}`});\n      },\n\n      onreadystatechange() {\n        if (/^(loaded|complete)$/.test(el.readyState)) {\n          success();\n        }\n      }\n    });\n  }\n\n  /**\n   * Determines whether to release.\n   *\n   * @param {Object} el The element\n   * @returns {boolean}\n   * @private\n   */\n  _shouldRelease(el) {\n    const isScript = (/^script$/i).test(el.nodeName);\n    return !isScript || !!(this.options.releaseAsync && el.src && el.hasAttribute('async'));\n  }\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/write-stream.js","/**\n * @file prescribe\n * @description Tiny, forgiving HTML parser\n * @version v1.1.3\n * @see {@link https://github.com/krux/prescribe/}\n * @license MIT\n * @author Derek Brans\n * @copyright 2017 Krux Digital, Inc\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Prescribe\"] = factory();\n\telse\n\t\troot[\"Prescribe\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tvar _HtmlParser = __webpack_require__(1);\n\n\tvar _HtmlParser2 = _interopRequireDefault(_HtmlParser);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tmodule.exports = _HtmlParser2['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\n\tvar _supports = __webpack_require__(2);\n\n\tvar supports = _interopRequireWildcard(_supports);\n\n\tvar _streamReaders = __webpack_require__(3);\n\n\tvar streamReaders = _interopRequireWildcard(_streamReaders);\n\n\tvar _fixedReadTokenFactory = __webpack_require__(6);\n\n\tvar _fixedReadTokenFactory2 = _interopRequireDefault(_fixedReadTokenFactory);\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Detection regular expressions.\n\t *\n\t * Order of detection matters: detection of one can only\n\t * succeed if detection of previous didn't\n\n\t * @type {Object}\n\t */\n\tvar detect = {\n\t  comment: /^<!--/,\n\t  endTag: /^<\\//,\n\t  atomicTag: /^<\\s*(script|style|noscript|iframe|textarea)[\\s\\/>]/i,\n\t  startTag: /^</,\n\t  chars: /^[^<]/\n\t};\n\n\t/**\n\t * HtmlParser provides the capability to parse HTML and return tokens\n\t * representing the tags and content.\n\t */\n\n\tvar HtmlParser = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} stream The initial parse stream contents.\n\t   * @param {Object} options The options\n\t   * @param {boolean} options.autoFix Set to true to automatically fix errors\n\t   */\n\t  function HtmlParser() {\n\t    var _this = this;\n\n\t    var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t    _classCallCheck(this, HtmlParser);\n\n\t    this.stream = stream;\n\n\t    var fix = false;\n\t    var fixedTokenOptions = {};\n\n\t    for (var key in supports) {\n\t      if (supports.hasOwnProperty(key)) {\n\t        if (options.autoFix) {\n\t          fixedTokenOptions[key + 'Fix'] = true; // !supports[key];\n\t        }\n\t        fix = fix || fixedTokenOptions[key + 'Fix'];\n\t      }\n\t    }\n\n\t    if (fix) {\n\t      this._readToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._readTokenImpl();\n\t      });\n\t      this._peekToken = (0, _fixedReadTokenFactory2['default'])(this, fixedTokenOptions, function () {\n\t        return _this._peekTokenImpl();\n\t      });\n\t    } else {\n\t      this._readToken = this._readTokenImpl;\n\t      this._peekToken = this._peekTokenImpl;\n\t    }\n\t  }\n\n\t  /**\n\t   * Appends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to append\n\t   */\n\n\n\t  HtmlParser.prototype.append = function append(str) {\n\t    this.stream += str;\n\t  };\n\n\t  /**\n\t   * Prepends the given string to the parse stream.\n\t   *\n\t   * @param {string} str The string to prepend\n\t   */\n\n\n\t  HtmlParser.prototype.prepend = function prepend(str) {\n\t    this.stream = str + this.stream;\n\t  };\n\n\t  /**\n\t   * The implementation of the token reading.\n\t   *\n\t   * @private\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._readTokenImpl = function _readTokenImpl() {\n\t    var token = this._peekTokenImpl();\n\t    if (token) {\n\t      this.stream = this.stream.slice(token.length);\n\t      return token;\n\t    }\n\t  };\n\n\t  /**\n\t   * The implementation of token peeking.\n\t   *\n\t   * @returns {?Token}\n\t   */\n\n\n\t  HtmlParser.prototype._peekTokenImpl = function _peekTokenImpl() {\n\t    for (var type in detect) {\n\t      if (detect.hasOwnProperty(type)) {\n\t        if (detect[type].test(this.stream)) {\n\t          var token = streamReaders[type](this.stream);\n\n\t          if (token) {\n\t            if (token.type === 'startTag' && /script|style/i.test(token.tagName)) {\n\t              return null;\n\t            } else {\n\t              token.text = this.stream.substr(0, token.length);\n\t              return token;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * The public token peeking interface.  Delegates to the basic token peeking\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.peekToken = function peekToken() {\n\t    return this._peekToken();\n\t  };\n\n\t  /**\n\t   * The public token reading interface.  Delegates to the basic token reading\n\t   * or a version that performs fixups depending on the `autoFix` setting in\n\t   * options.\n\t   *\n\t   * @returns {object}\n\t   */\n\n\n\t  HtmlParser.prototype.readToken = function readToken() {\n\t    return this._readToken();\n\t  };\n\n\t  /**\n\t   * Read tokens and hand to the given handlers.\n\t   *\n\t   * @param {Object} handlers The handlers to use for the different tokens.\n\t   */\n\n\n\t  HtmlParser.prototype.readTokens = function readTokens(handlers) {\n\t    var tok = void 0;\n\t    while (tok = this.readToken()) {\n\t      // continue until we get an explicit \"false\" return\n\t      if (handlers[tok.type] && handlers[tok.type](tok) === false) {\n\t        return;\n\t      }\n\t    }\n\t  };\n\n\t  /**\n\t   * Clears the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream before clearing.\n\t   */\n\n\n\t  HtmlParser.prototype.clear = function clear() {\n\t    var rest = this.stream;\n\t    this.stream = '';\n\t    return rest;\n\t  };\n\n\t  /**\n\t   * Returns the rest of the parse stream.\n\t   *\n\t   * @returns {string} The contents of the parse stream.\n\t   */\n\n\n\t  HtmlParser.prototype.rest = function rest() {\n\t    return this.stream;\n\t  };\n\n\t  return HtmlParser;\n\t}();\n\n\texports['default'] = HtmlParser;\n\n\n\tHtmlParser.tokenToString = function (tok) {\n\t  return tok.toString();\n\t};\n\n\tHtmlParser.escapeAttributes = function (attrs) {\n\t  var escapedAttrs = {};\n\n\t  for (var name in attrs) {\n\t    if (attrs.hasOwnProperty(name)) {\n\t      escapedAttrs[name] = (0, _utils.escapeQuotes)(attrs[name], null);\n\t    }\n\t  }\n\n\t  return escapedAttrs;\n\t};\n\n\tHtmlParser.supports = supports;\n\n\tfor (var key in supports) {\n\t  if (supports.hasOwnProperty(key)) {\n\t    HtmlParser.browserHasFlaw = HtmlParser.browserHasFlaw || !supports[key] && key;\n\t  }\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\tvar tagSoup = false;\n\tvar selfClose = false;\n\n\tvar work = window.document.createElement('div');\n\n\ttry {\n\t  var html = '<P><I></P></I>';\n\t  work.innerHTML = html;\n\t  exports.tagSoup = tagSoup = work.innerHTML !== html;\n\t} catch (e) {\n\t  exports.tagSoup = tagSoup = false;\n\t}\n\n\ttry {\n\t  work.innerHTML = '<P><i><P></P></i></P>';\n\t  exports.selfClose = selfClose = work.childNodes.length === 2;\n\t} catch (e) {\n\t  exports.selfClose = selfClose = false;\n\t}\n\n\twork = null;\n\n\texports.tagSoup = tagSoup;\n\texports.selfClose = selfClose;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.comment = comment;\n\texports.chars = chars;\n\texports.startTag = startTag;\n\texports.atomicTag = atomicTag;\n\texports.endTag = endTag;\n\n\tvar _tokens = __webpack_require__(4);\n\n\t/**\n\t * Regular Expressions for parsing tags and attributes\n\t *\n\t * @type {Object}\n\t */\n\tvar REGEXES = {\n\t  startTag: /^<([\\-A-Za-z0-9_!:]+)((?:\\s+[\\w\\-]+(?:\\s*=?\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/,\n\t  endTag: /^<\\/([\\-A-Za-z0-9_:]+)[^>]*>/,\n\t  attr: /(?:([\\-A-Za-z0-9_]+)\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|([^>\\s]+)))|(?:([\\-A-Za-z0-9_]+)(\\s|$)+)/g,\n\t  fillAttr: /^(checked|compact|declare|defer|disabled|ismap|multiple|nohref|noresize|noshade|nowrap|readonly|selected)$/i\n\t};\n\n\t/**\n\t * Reads a comment token\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CommentToken}\n\t */\n\tfunction comment(stream) {\n\t  var index = stream.indexOf('-->');\n\t  if (index >= 0) {\n\t    return new _tokens.CommentToken(stream.substr(4, index - 1), index + 3);\n\t  }\n\t}\n\n\t/**\n\t * Reads non-tag characters.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {CharsToken}\n\t */\n\tfunction chars(stream) {\n\t  var index = stream.indexOf('<');\n\t  return new _tokens.CharsToken(index >= 0 ? index : stream.length);\n\t}\n\n\t/**\n\t * Reads start tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {StartTagToken}\n\t */\n\tfunction startTag(stream) {\n\t  var endTagIndex = stream.indexOf('>');\n\t  if (endTagIndex !== -1) {\n\t    var match = stream.match(REGEXES.startTag);\n\t    if (match) {\n\t      var attrs = {};\n\t      var booleanAttrs = {};\n\t      var rest = match[2];\n\n\t      match[2].replace(REGEXES.attr, function (match, name) {\n\t        if (!(arguments[2] || arguments[3] || arguments[4] || arguments[5])) {\n\t          attrs[name] = '';\n\t        } else if (arguments[5]) {\n\t          attrs[arguments[5]] = '';\n\t          booleanAttrs[arguments[5]] = true;\n\t        } else {\n\t          attrs[name] = arguments[2] || arguments[3] || arguments[4] || REGEXES.fillAttr.test(name) && name || '';\n\t        }\n\n\t        rest = rest.replace(match, '');\n\t      });\n\n\t      return new _tokens.StartTagToken(match[1], match[0].length, attrs, booleanAttrs, !!match[3], rest.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''));\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads atomic tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {AtomicTagToken}\n\t */\n\tfunction atomicTag(stream) {\n\t  var start = startTag(stream);\n\t  if (start) {\n\t    var rest = stream.slice(start.length);\n\t    // for optimization, we check first just for the end tag\n\t    if (rest.match(new RegExp('<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'))) {\n\t      // capturing the content is inefficient, so we do it inside the if\n\t      var match = rest.match(new RegExp('([\\\\s\\\\S]*?)<\\/\\\\s*' + start.tagName + '\\\\s*>', 'i'));\n\t      if (match) {\n\t        return new _tokens.AtomicTagToken(start.tagName, match[0].length + start.length, start.attrs, start.booleanAttrs, match[1]);\n\t      }\n\t    }\n\t  }\n\t}\n\n\t/**\n\t * Reads an end tag token.\n\t *\n\t * @param {string} stream The input stream\n\t * @returns {EndTagToken}\n\t */\n\tfunction endTag(stream) {\n\t  var match = stream.match(REGEXES.endTag);\n\t  if (match) {\n\t    return new _tokens.EndTagToken(match[1], match[0].length);\n\t  }\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.EndTagToken = exports.AtomicTagToken = exports.StartTagToken = exports.TagToken = exports.CharsToken = exports.CommentToken = exports.Token = undefined;\n\n\tvar _utils = __webpack_require__(5);\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\t/**\n\t * Token is a base class for all token types parsed.  Note we don't actually\n\t * use intheritance due to IE8's non-existent ES5 support.\n\t */\n\tvar Token =\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} type The type of the Token.\n\t * @param {Number} length The length of the Token text.\n\t */\n\texports.Token = function Token(type, length) {\n\t  _classCallCheck(this, Token);\n\n\t  this.type = type;\n\t  this.length = length;\n\t  this.text = '';\n\t};\n\n\t/**\n\t * CommentToken represents comment tags.\n\t */\n\n\n\tvar CommentToken = exports.CommentToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} content The content of the comment\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CommentToken(content, length) {\n\t    _classCallCheck(this, CommentToken);\n\n\t    this.type = 'comment';\n\t    this.length = length || (content ? content.length : 0);\n\t    this.text = '';\n\t    this.content = content;\n\t  }\n\n\t  CommentToken.prototype.toString = function toString() {\n\t    return '<!--' + this.content;\n\t  };\n\n\t  return CommentToken;\n\t}();\n\n\t/**\n\t * CharsToken represents non-tag characters.\n\t */\n\n\n\tvar CharsToken = exports.CharsToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {Number} length The length of the Token text.\n\t   */\n\t  function CharsToken(length) {\n\t    _classCallCheck(this, CharsToken);\n\n\t    this.type = 'chars';\n\t    this.length = length;\n\t    this.text = '';\n\t  }\n\n\t  CharsToken.prototype.toString = function toString() {\n\t    return this.text;\n\t  };\n\n\t  return CharsToken;\n\t}();\n\n\t/**\n\t * TagToken is a base class for all tag-based Tokens.\n\t */\n\n\n\tvar TagToken = exports.TagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} type The type of the token.\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text.\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   */\n\t  function TagToken(type, tagName, length, attrs, booleanAttrs) {\n\t    _classCallCheck(this, TagToken);\n\n\t    this.type = type;\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t  }\n\n\t  /**\n\t   * Formats the given token tag.\n\t   *\n\t   * @param {TagToken} tok The TagToken to format.\n\t   * @param {?string} [content=null] The content of the token.\n\t   * @returns {string} The formatted tag.\n\t   */\n\n\n\t  TagToken.formatTag = function formatTag(tok) {\n\t    var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t    var str = '<' + tok.tagName;\n\t    for (var key in tok.attrs) {\n\t      if (tok.attrs.hasOwnProperty(key)) {\n\t        str += ' ' + key;\n\n\t        var val = tok.attrs[key];\n\t        if (typeof tok.booleanAttrs === 'undefined' || typeof tok.booleanAttrs[key] === 'undefined') {\n\t          str += '=\"' + (0, _utils.escapeQuotes)(val) + '\"';\n\t        }\n\t      }\n\t    }\n\n\t    if (tok.rest) {\n\t      str += ' ' + tok.rest;\n\t    }\n\n\t    if (tok.unary && !tok.html5Unary) {\n\t      str += '/>';\n\t    } else {\n\t      str += '>';\n\t    }\n\n\t    if (content !== undefined && content !== null) {\n\t      str += content + '</' + tok.tagName + '>';\n\t    }\n\n\t    return str;\n\t  };\n\n\t  return TagToken;\n\t}();\n\n\t/**\n\t * StartTagToken represents a start token.\n\t */\n\n\n\tvar StartTagToken = exports.StartTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The tag name.\n\t   * @param {Number} length The length of the Token text\n\t   * @param {Object} attrs The dictionary of attributes and values\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {boolean} unary True if the tag is a unary tag\n\t   * @param {string} rest The rest of the content.\n\t   */\n\t  function StartTagToken(tagName, length, attrs, booleanAttrs, unary, rest) {\n\t    _classCallCheck(this, StartTagToken);\n\n\t    this.type = 'startTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.html5Unary = false;\n\t    this.unary = unary;\n\t    this.rest = rest;\n\t  }\n\n\t  StartTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this);\n\t  };\n\n\t  return StartTagToken;\n\t}();\n\n\t/**\n\t * AtomicTagToken represents an atomic tag.\n\t */\n\n\n\tvar AtomicTagToken = exports.AtomicTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   * @param {Object} attrs The attributes.\n\t   * @param {Object} booleanAttrs If an entry has 'true' then the attribute\n\t   *                              is a boolean attribute\n\t   * @param {string} content The content of the tag.\n\t   */\n\t  function AtomicTagToken(tagName, length, attrs, booleanAttrs, content) {\n\t    _classCallCheck(this, AtomicTagToken);\n\n\t    this.type = 'atomicTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t    this.attrs = attrs;\n\t    this.booleanAttrs = booleanAttrs;\n\t    this.unary = false;\n\t    this.html5Unary = false;\n\t    this.content = content;\n\t  }\n\n\t  AtomicTagToken.prototype.toString = function toString() {\n\t    return TagToken.formatTag(this, this.content);\n\t  };\n\n\t  return AtomicTagToken;\n\t}();\n\n\t/**\n\t * EndTagToken represents an end tag.\n\t */\n\n\n\tvar EndTagToken = exports.EndTagToken = function () {\n\t  /**\n\t   * Constructor.\n\t   *\n\t   * @param {string} tagName The name of the tag.\n\t   * @param {Number} length The length of the tag text.\n\t   */\n\t  function EndTagToken(tagName, length) {\n\t    _classCallCheck(this, EndTagToken);\n\n\t    this.type = 'endTag';\n\t    this.length = length;\n\t    this.text = '';\n\t    this.tagName = tagName;\n\t  }\n\n\t  EndTagToken.prototype.toString = function toString() {\n\t    return '</' + this.tagName + '>';\n\t  };\n\n\t  return EndTagToken;\n\t}();\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports.escapeQuotes = escapeQuotes;\n\n\t/**\n\t * Escape quotes in the given value.\n\t *\n\t * @param {string} value The value to escape.\n\t * @param {string} [defaultValue=''] The default value to return if value is falsy.\n\t * @returns {string}\n\t */\n\tfunction escapeQuotes(value) {\n\t  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\t  // There's no lookback in JS, so /(^|[^\\\\])\"/ only matches the first of two `\"`s.\n\t  // Instead, just match anything before a double-quote and escape if it's not already escaped.\n\t  return !value ? defaultValue : value.replace(/([^\"]*)\"/g, function (_, prefix) {\n\t    return (/\\\\/.test(prefix) ? prefix + '\"' : prefix + '\\\\\"'\n\t    );\n\t  });\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = fixedReadTokenFactory;\n\t/**\n\t * Empty Elements - HTML 4.01\n\t *\n\t * @type {RegExp}\n\t */\n\tvar EMPTY = /^(AREA|BASE|BASEFONT|BR|COL|FRAME|HR|IMG|INPUT|ISINDEX|LINK|META|PARAM|EMBED)$/i;\n\n\t/**\n\t * Elements that you can intentionally leave open (and which close themselves)\n\t *\n\t * @type {RegExp}\n\t */\n\tvar CLOSESELF = /^(COLGROUP|DD|DT|LI|OPTIONS|P|TD|TFOOT|TH|THEAD|TR)$/i;\n\n\t/**\n\t * Corrects a token.\n\t *\n\t * @param {Token} tok The token to correct\n\t * @returns {Token} The corrected token\n\t */\n\tfunction correct(tok) {\n\t  if (tok && tok.type === 'startTag') {\n\t    tok.unary = EMPTY.test(tok.tagName) || tok.unary;\n\t    tok.html5Unary = !/\\/>$/.test(tok.text);\n\t  }\n\t  return tok;\n\t}\n\n\t/**\n\t * Peeks at the next token in the parser.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Token} The next token\n\t */\n\tfunction peekToken(parser, readTokenImpl) {\n\t  var tmp = parser.stream;\n\t  var tok = correct(readTokenImpl());\n\t  parser.stream = tmp;\n\t  return tok;\n\t}\n\n\t/**\n\t * Closes the last token.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Array<Token>} stack The stack\n\t */\n\tfunction closeLast(parser, stack) {\n\t  var tok = stack.pop();\n\n\t  // prepend close tag to stream.\n\t  parser.prepend('</' + tok.tagName + '>');\n\t}\n\n\t/**\n\t * Create a new token stack.\n\t *\n\t * @returns {Array<Token>}\n\t */\n\tfunction newStack() {\n\t  var stack = [];\n\n\t  stack.last = function () {\n\t    return this[this.length - 1];\n\t  };\n\n\t  stack.lastTagNameEq = function (tagName) {\n\t    var last = this.last();\n\t    return last && last.tagName && last.tagName.toUpperCase() === tagName.toUpperCase();\n\t  };\n\n\t  stack.containsTagName = function (tagName) {\n\t    for (var i = 0, tok; tok = this[i]; i++) {\n\t      if (tok.tagName === tagName) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  };\n\n\t  return stack;\n\t}\n\n\t/**\n\t * Return a readToken implementation that fixes input.\n\t *\n\t * @param {HtmlParser} parser The parser\n\t * @param {Object} options Options for fixing\n\t * @param {boolean} options.tagSoupFix True to fix tag soup scenarios\n\t * @param {boolean} options.selfCloseFix True to fix self-closing tags\n\t * @param {Function} readTokenImpl The underlying readToken implementation\n\t * @returns {Function}\n\t */\n\tfunction fixedReadTokenFactory(parser, options, readTokenImpl) {\n\t  var stack = newStack();\n\n\t  var handlers = {\n\t    startTag: function startTag(tok) {\n\t      var tagName = tok.tagName;\n\n\t      if (tagName.toUpperCase() === 'TR' && stack.lastTagNameEq('TABLE')) {\n\t        parser.prepend('<TBODY>');\n\t        prepareNextToken();\n\t      } else if (options.selfCloseFix && CLOSESELF.test(tagName) && stack.containsTagName(tagName)) {\n\t        if (stack.lastTagNameEq(tagName)) {\n\t          closeLast(parser, stack);\n\t        } else {\n\t          parser.prepend('</' + tok.tagName + '>');\n\t          prepareNextToken();\n\t        }\n\t      } else if (!tok.unary) {\n\t        stack.push(tok);\n\t      }\n\t    },\n\t    endTag: function endTag(tok) {\n\t      var last = stack.last();\n\t      if (last) {\n\t        if (options.tagSoupFix && !stack.lastTagNameEq(tok.tagName)) {\n\t          // cleanup tag soup\n\t          closeLast(parser, stack);\n\t        } else {\n\t          stack.pop();\n\t        }\n\t      } else if (options.tagSoupFix) {\n\t        // cleanup tag soup part 2: skip this token\n\t        readTokenImpl();\n\t        prepareNextToken();\n\t      }\n\t    }\n\t  };\n\n\t  function prepareNextToken() {\n\t    var tok = peekToken(parser, readTokenImpl);\n\t    if (tok && handlers[tok.type]) {\n\t      handlers[tok.type](tok);\n\t    }\n\t  }\n\n\t  return function fixedReadToken() {\n\t    prepareNextToken();\n\t    return correct(readTokenImpl());\n\t  };\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/prescribe/dist/prescribe.js\n// module id = 3\n// module chunks = 0","/**\n * Determine if the thing is not undefined and not null.\n *\n * @param {*} thing The thing to test\n * @returns {boolean} True if the thing is not undefined and not null.\n */\nexport function existy(thing) {\n  return thing !== void 0 && thing !== null;\n}\n\n/**\n * Is this a function?\n *\n * @param {*} x The variable to test\n * @returns {boolean} True if the variable is a function\n */\nexport function isFunction(x) {\n  return 'function' === typeof x;\n}\n\n/**\n * Loop over each item in an array-like value.\n *\n * @param {Array<*>} arr The array to loop over\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function each(arr, fn, target) {\n  let i;\n  const len = (arr && arr.length) || 0;\n  for (i = 0; i < len; i++) {\n    fn.call(target, arr[i], i);\n  }\n}\n\n/**\n * Loop over each key/value pair in a hash.\n *\n * @param {Object} obj The object\n * @param {Function} fn The function to call\n * @param {?Object} target The object to bind to the function\n */\nexport function eachKey(obj, fn, target) {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(target, key, obj[key]);\n    }\n  }\n}\n\n/**\n * Set default options where some option was not specified.\n *\n * @param {Object} options The destination\n * @param {Object} _defaults The defaults\n * @returns {Object}\n */\nexport function defaults(options, _defaults) {\n  options = options || {};\n  eachKey(_defaults, function(key, val) {\n    if (!existy(options[key])) {\n      options[key] = val;\n    }\n  });\n  return options;\n}\n\n/**\n * Convert value (e.g., a NodeList) to an array.\n *\n * @param {*} obj The object\n * @returns {Array<*>}\n */\nexport function toArray(obj) {\n  try {\n    return Array.prototype.slice.call(obj);\n  } catch (e) {\n    const ret = [];\n    each(obj, function(val) {\n      ret.push(val);\n    });\n    return ret;\n  }\n}\n\n/**\n * Get the last item in an array\n *\n * @param {Array<*>} array The array\n * @returns {*} The last item in the array\n */\nexport function last(array) {\n  return array[array.length - 1];\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @param {String} tag The tag name\n * @returns {boolean} True if the token is a script tag\n */\nexport function isTag(tok, tag) {\n  return !tok ||\n    !(tok.type === 'startTag' || tok.type === 'atomicTag') ||\n    !('tagName' in tok) ? !1 : !!~tok.tagName.toLowerCase().indexOf(tag);\n}\n\n/**\n * Test if token is a script tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a script tag\n */\nexport function isScript(tok) {\n  return isTag(tok, 'script');\n}\n\n/**\n * Test if token is a style tag.\n *\n * @param {Object} tok The token\n * @returns {boolean} True if the token is a style tag\n */\nexport function isStyle(tok) {\n  return isTag(tok, 'style');\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}